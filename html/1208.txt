jQuery
	(당연히 jquery obj 이여서 불러오는 객체는 모두 jquery obj 이여야함)
		(그냥 dom obj 이면 $( ) 안에 다시 넣어줘서 jquery obj로 바꿔주자)
			$(this)

	jquery("selector") == $("selector") == document.querySelector(".all")
		obj.find("selector")
	btnAll.on("click", f ()) == btnAll.addEventListener("click", f ())
	gnb.addClass("on") == gnb.classList.add("on")
		addClass, removeClass, hasClass, toggleClass

	모든 event 에 대한 callback이 que에 쌓이는데
		jq.stop().method() 를 쓰게 되면
		지금 하고 있는 callback 중단하고 이것부터 봐줘 가 된다

	document.queryselector랑 $() 랑 다르다
		qs = object htmlelement
		jq = jq object (더 detail)

	그리고 list 도 foreach 없이 .on 만으로 event listener 달아줄수 있고
	all 안붙여도 다 가져옴

	모든 method가 객체를 다시 반환함으로 method chaining 이 가능

	list에 대해 eq 제공
		jq_list.eq(0).hide()


java
	runtime 언어
		lint -> compile -> run
		틀린거 있으면 오류 뜨고 컴파일자체가 안됨
javascript
	script 언어
		lint -> run
		틀린거 있어도 runtime까지는 감


javascript this
	context 환경에 따라 this가 달라짐(python이랑 다를바 없음)
		lexical environment
		arrow function에는 없다
	누가 함수를 불렀나!(event listener의 call back을 누가 불렀나)
		array에 foreach 써준거면 누른놈 각각의 this 가 다르겠지


js 에서는 파일이 달라도 합쳐서 컴파일하기 때문에
	변수명이 전체 합쳐지는 파일에서 1개만 선언 가능
	iife 사용으로 충돌 방노력 진행중                                                                                                                         
		함수를 괄호 안에 넣기<callback 함수 처럼 실행 괄호 안에서 선언>

js function에서 parameter 많아지면
	obj 받아서 obj.param1 으로 처리


function vs class
	function MyClass(par1) { this.par1 = par1 } 해도 되는데
	prototype 조작 및 상속을 편하게 하기 위해
	class MyClass { constructor(par1) {this.par1 = par1} } 문법이
	es6에 생김

	근데 class 자체 역시 list라고 생각 가능
	일반적인 list는 key가 idx 고 class는 method 라고 생각하면 됨

	애초에 array vs linked list 의 원 자료형을 배열(array)이라고 안부르는 이유가
	자료는 모두 나열 형태임


gsap 기본 input
  gsap.to(".popup", {
    duration: 1,
    top: "-100%",
    ease: "back.in",
    onComplete: function () {
      popup.remove();
    },
  });