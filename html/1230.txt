java gui -> AWT > java FX, java Swing 등등

java swing
	배치관리자 필요 -> 기본은 요소들끼리 겹치기
		container.setLayout(new FlowLayout())
		flow, grid, border, card(좌표찍어, 기본값)

	


java
	java는 같은 class 안에서는 this 없어도 됨
	this.method1() 대신 method1() 써도 됨

	class instances[] = new class[n]

javascript
	객체 생성
	const person1 = new Person('Bob')

function Person(name) {
  this.name = name;
  this.greeting = function() {
    alert('Hi! I\'m ' + this.name + '.');
  };
}

	근데 instance.greeting이 매번 새로 정의됨!
		prototype을 이용하면 class method 처럼 사용 가능
		python은 항상 prototype

	prototype
		상속을 prototype을 통해서 함(cummulative by chaining임)

person1.valueOf()
브라우저는 우선 person1 객체가 valueOf() 메소드를 가지고 있는지 체크합니다.
없으므로 person1의 프로토타입 객체(Person() 생성자의 프로토타입)에 valueOf() 메소드가 있는지 체크합니다.
여전히 없으므로 Person() 생성자의 프로토타입 객체의 프로토타입 객체(Object() 생성자의 프로토타입)가 valueOf() 메소드를 가지고 있는지 체크합니다. 여기에 있으니 호출하며 끝납니다!

Note: 프로토타입 체인에서 한 객체의 메소드와 속성들이 다른 객체로 복사되는 것이 아님을 재차 언급합니다. — 위에서 보시다 시피 체인을 타고 올라가며 접근할 뿐입니다.

Object.is(), Object.keys()등 prototype 버킷에 정의되지 않은 멤버들은 상속되지 않습니다

사실 일반적인 방식으로는 속성은 생성자에서, 메소드는 프로토타입에서 정의합니다. 생성자에는 속성에 대한 정의만 있으며 메소드는 별도의 블럭으로 구분할 수 있으니 코드를 읽기가 훨씬 쉬워집니다. 아래처럼요:

